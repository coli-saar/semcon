# Performs semantic construction and can answer Geoquery queries.
# Alexander Koller, 10 May 2015
#
# Important functions:
#
# gr = load_grammar(cfg_filename, semcon_filename)
# Loads a grammar and semcon rules from files. These will typically
# have been generated by grcompile.py.
#
# mr = parse(sentence, gr)
# Parses a sentence and (if successful) returns the semantic representation
# as an NLTK Logic object.
#
# query(mr)
# Runs the given query using the Geoquery Prolog system and outputs
# the answers. In order to use this, you need to download two support
# files from the Geoquery website:
#
# - ftp://ftp.cs.utexas.edu/pub/mooney/nl-ilp-data/geosystem/geobase
#   (save as geobase.pl)
#
# - ftp://ftp.cs.utexas.edu/pub/mooney/nl-ilp-data/geosystem/geoquery
#   (save as geoquery.pl)
#
# You also need to install SWI Prolog for your platform
# (get it from http://www.swi-prolog.org/) and set the SWIPL variable
# below to the path of the swipl executable.




from __future__ import print_function
import nltk
from interpolate import s
import importlib
import tempfile
import subprocess
import os
import re

lexpr = nltk.logic.Expression.fromstring

def sem(tree, semrules):
    return lexpr(collect_sem(tree, semrules))

def label(tree_or_leaf):
    if isinstance(tree_or_leaf, nltk.tree.Tree):
        return tree_or_leaf.label()
    else:
        return tree_or_leaf

def collect_sem(tree, semrules):
    if isinstance(tree, nltk.tree.Tree):
        child_names = [label(child) for child in tree]
        key = label(tree) + " -> " + " ".join(child_names)
        compose_fn = semrules[key]

        if isinstance(compose_fn, str):
            return compose_fn
        else:
            # collect non-null semantic contributions of children
            child_sems = filter(lambda x:x, (collect_sem(child, semrules) for child in tree))
            # and apply composition rule to them
            ret = compose_fn(child_sems)
            return ret
    else:
        return None # ignore in semantic analysis


def load_grammar(cfg, sem):
    cp = nltk.parse.load_parser(cfg, cache=False)
    sem_module = importlib.import_module(sem)
    sem_module = reload(sem_module)
    semrules = sem_module.semrules

    return (cp, semrules)


def parse(sentence, parser):
    (cp, semrules) = parser
    treegen = cp.parse(sentence.split())

    trees = list(treegen)
    print("Found {0} parse trees.".format(len(trees)))

    fp = trees[0]
    print("Using parse tree: " + str(fp))

    semantics = sem(fp, semrules).simplify()
    print("Semantics: " + str(semantics))
    
    return semantics


# paths for executing Geoquery queries
SWIPL = "/Applications/SWI-Prolog.app/Contents/MacOS/swipl"

query_template = ''':- initialization main.
main :-
  [geoquery],
  {0},
  halt(0).'''

answer_re = re.compile(r"Answer\s*=\s*\[([^\]]*)\]")
underscore_re = re.compile(r"([a-zA-Z0-9_]*\+[a-zA-Z0-9_+]*)")

# rewrite meaning repr to Prolog query term
def to_geoquery(querystr):
    q = querystr.replace("&", ",") # replace conjunction by comma
    q = underscore_re.sub(r"'\1'", q).replace("+", " ") # replace new+mexico by 'new mexico'
    return q

def query(semantics):
    q = to_geoquery(str(semantics))
    file_content = query_template.format(q)

    print(q)

    # write Prolog query to file
    tmpfile = tempfile.mkstemp(suffix=".pl")[1]
    f = open(tmpfile, "w")
    print(file_content, file=f)
    f.close()

    # run Prolog to resolve query and collect output
    FNULL = open(os.devnull, 'w')    
    proc = subprocess.Popen([SWIPL, "-q", "-f", tmpfile], stdout=subprocess.PIPE, stderr=FNULL)
    output = proc.stdout.read()

    # find correct line and print it
    r = answer_re.search(output)
    if r:
        answers = r.group(1).split(",")
        print("\nFound {0} answers:".format(len(answers)))
        for answer in answers:
            print(" - " + answer)
    else:
        print("No answers found.")
    
